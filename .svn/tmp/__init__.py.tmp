#!/usr/bin/env python
#
# Copyright 2011 HubSpot Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = "markitecht (Christopher O'Donnell)"
__author__ = "applesauce (Adrian Mott)"
__author__ = "not Nelly (Matt Furtado)"

import re
import hmac
import base64
import urllib
import httplib
import logging
from xml.dom import minidom
from blog_objects import *
from blog_post_object import *
from blog_comments import *

try:
  import hashlib
except ImportError:
  import md5 as hashlib

try:
  import json as simplejson
  simplejson.loads
except (ImportError, AttributeError):
  try:
    import simplejson
    simplejson.loads
  except (ImportError, AttributeError):
    try:
      from django.utils import simplejson
      simplejson.loads
    except (ImportError, AttributeError):
      try:
        import jsonlib as simplejson
        simplejson.loads
      except:
        pass

# from hubspot.settings import settings as hs_settings

# HUBSPOT_API_BASE = hs_settings.HUBSPOT_API_BASE
HUBSPOT_API_BASE = "hubapi.com"
HUBSPOT_BLOG_API_VERSION = '1'
HUBSPOT_LEADS_API_VERSION = '1'
HUBSPOT_KEYWORDS_API_VERSION = '1'


class HubSpotClient(object):
  '''Client for interacting with the HubSpot APIs'''
  
  def __init__(self, api_key):
    self.api_key = api_key
    self.portal_id = None
  
  def _create_path(self, method):
    pass
  
  def _http_error(self, code, message, url):
    logging.error('Client request error. Code: %s - Reason: %s - URL: %s' % (str(code), message, url))
  
  def _prepare_response(self, code, data):
    msg = self._get_msg(code)
    return {'status': code, 'body': data, 'msg': msg}
    # Is this ideal?  Should we maybe consider just returning raw data and let the user deal with it on their own?
  
  def _get_msg(self, code):
    return None
  
  def _deal_with_content_type(self, output):
    if output == "atom":
      content_t = "atom+xml"
    elif output == "xml":
      content_t = "atom+xml"
    elif output == "json":
      content_t = "json"
    return content_t
  
  def _make_request(self, method, params, data=None, request_method='GET', url=None, content_type='application/json'):
    """only for API's that only return JSON (leads, lead nurturing, settings, events)"""
    
    params['hapikey'] = self.api_key
    
    if self.portal_id:
      params['portalId'] = self.portal_id
    
    if not url: url = '/%s?%s' %(
      self._create_path(method),
      urllib.urlencode(params)
    )
    
    client = httplib.HTTPSConnection(HUBSPOT_API_BASE)
    if data and not isinstance(data, str):
      data = urllib.urlencode(data)
    
    headers = {'Content-Type': content_type}
    client.request(request_method, url, data, headers)
    result = client.getresponse()
    if result.status < 400:
      body = result.read()
      client.close()
      if body:
        return self._prepare_response(result.status, simplejson.loads(body))
      else:
        return self._prepare_response(result.status, {})
    else:
      client.close()
      self._http_error(result.status, 
        result.reason,
        url
      )
      return self._prepare_response(result.status, {})

  def _make_request_blog(self, method, params, content_type, data, request_method, url=None):
    """_make_request_blog deals with API's that can return different types of content (XML or JSON) like the Blog API"""
    
    params['hapikey'] = self.api_key
    if self.portal_id:
      params['portalId'] = self.portal_id
    
    if not url: url = '/%s?%s' %(
      self._create_path(method),
      urllib.urlencode(params)
    )

    client = httplib.HTTPSConnection(HUBSPOT_API_BASE)
    if data and not isinstance(data, str):
      data = urllib.urlencode(data)

    headers = {'Content-Type': content_type}
    client.request(request_method, url, data, headers)
    result = client.getresponse()
    if result.status < 400:
      body = result.read()
      client.close()
      return body
    else:
      client.close()
      self._http_error(result.status, 
        result.reason,
        url
      )
      return self._prepare_response(result.status, {})
  

class HubSpotLeadsClient(HubSpotClient):
  """
    The PySpot Leads client uses the _make_request method to call the API for data.  It returns only JSON in the standard format:
    { status: 'status', body: 'data from API call', msg: 'message' }
    PLEASE NOTE that the 'body' here is decoded JSON.
  """
  def _create_path(self, method):
    return 'leads/v%s/%s' % (HUBSPOT_LEADS_API_VERSION, method)
  
  def create_lead(self, ip_address, cookie, fields):
    pass
    
  def get_lead(self, lead_guid):
    return self._make_request('list/', {'guids[0]': lead_guid})
  
  def search_leads(self, term, params):
    params['search'] = term
    return self._make_request('list/', params)
    
  def update_lead(self, lead_guid, data):
    return self._make_request(
      'lead/%s/' % lead_guid, {},
      data=data, request_method='PUT'
    )
  
  def get_callback_urls(self):
    return self._make_request(
      'callback-url', {}
    )
    
  def register_callback_url(self, url):
    return self._make_request(
      'callback-url', {'url': url}, data={'url': url}, request_method='POST'
    )
    
  def close_lead(self, lead_guid):
    now = int(time.time()*1000)
    data = {'closedAt': now}
    return self._make_request(
      'lead/%s/' % lead_guid, data, request_method='PUT'
    )
    

class HubSpotLeadNurtureClient(HubSpotClient):
  
  def _create_path(self, method):
    return 'nurture/v%s/%s' % (HUBSPOT_LEADS_API_VERSION, method)
    
  def get_campaigns(self):
    return self._make_request(
      'campaigns', {}
    )
    
  def get_leads(self, campaign_guid):
    return self._make_request(
      'campaign/%s/list' % campaign_guid, {}
    )
  
  def get_history(self, lead_guid):
    return self._make_request(
      'lead/%s' % lead_guid, {}
    )
    
  def enroll_lead(self, campaign_guid):
    return self._make_request(
      'campaign/%s/add' % campaign_guid, {}
    )
    
  def unenroll_lead(self, campaign_guid):
    return self._make_request(
      'campaign/%s/remove' % campaign_guid, {}
    )


class HubSpotEventClient(HubSpotClient):
  
  def _create_path(self, method):
    return 'events/v%s/%s' % (HUBSPOT_LEADS_API_VERSION, method)
    
  def _get_msg(self, code):
    messages = {
      200: 'successfully retrieved events',
      201: 'successfully created new event',
      401: 'unauthorized request',
      500: 'internal server error'
    }
    return messages[code]
    
  def get_events(self):
    return self._make_request(
      'events', {}
    )
    
  def create_event(self, description, create_date, url, event_type):
    event_data = {
      'description': description,
      'createDate': create_date,
      'url': url,
      'eventType': event_type
    }
    return self._make_request(
      'events', {}, data=event_data, request_method='POST'
    )


class HubSpotSettingsClient(HubSpotClient):
  
  def _create_path(self, method):
    return 'settings/v%s/%s' % (HUBSPOT_LEADS_API_VERSION, method)
    
  def _get_msg(self, code):
    messages = {
      200: 'successfully retrieved settings',
      201: 'successfully updated or created new setting',
      401: 'unauthorized request',
      500: 'internal server error'
    }
    return messages[code]
    
  def get_settings(self):
    return self._make_request(
      'settings', {}
    )    
    
  def update_settings(self, data):
    return self._make_request(
      'settings', {}, request_method='POST', data=data
    )
    
class HubSpotBlogClient(HubSpotClient):
  
  def _create_path(self, method):
    return 'blog/v%s/%s' % (HUBSPOT_BLOG_API_VERSION, method)

  def _get_msg(self, code):
    messages = {
      200: 'successfully retrieved request',
      201: 'successfully updated or created resource',
      400: 'unknown error',
      500: 'internal server error'
    }
    return messages[code]
  
  """Create new class called hubspotblog - this will include getting blog info"""
  def get_blogs(self, output_type):
    out_type = self._deal_with_content_type(output_type)
    blogs_returned = self._make_request('list.%s' % output_type, {}, 'application/%s' % out_type)
    blog_objs = []
    for blog_json in blogs_returned['body']:
      individual_blog_obj = Blog(blog_json)
      blog_objs.append(individual_blog_obj)
    return blog_objs
  
  def get_blog(self, blog_guid, output_type):
    out_type = self._deal_with_content_type(output_type)
    return self._make_request_blog(blog_guid, {}, 'application/%s' % out_type)
  
  def get_posts(self, blog_guid, output_type):
    """Need to add error checking on the content type.  If its not atom or json for instance"""
    out_type = self._deal_with_content_type(output_type)
    return self._make_request_blog('%s/posts.%s' % (blog_guid, output_type), {}, 'application/%s' % out_type)
  
  def get_drafts(self, blog_guid, output_type):
    out_type = self._deal_with_content_type(output_type)
    return self._make_request_blog('%s/posts' % blog_guid, {'draft': 'true'}, 'application/%s' % out_type)
  
  def get_published_posts(self, blog_guid):
    return self._make_request(
      '%s/posts' % blog_guid, {'draft': 'false'}
    )
    
  def get_blog_comments(self, blog_guid):
    return self._make_request(
      '%s/comments' % blog_guid, {}
    )
    
  def get_post(self, post_guid):
    return self._make_request(
      'posts/%s' % post_guid, {}
    )
    
  def get_post_comments(self, post_guid):
    return self._make_request(
      'posts/%s/comments' % post_guid, {}
    )
  
  def get_comment(self, comment_guid):
    return self._make_request(
      'comments/%s' % comment_guid, {}
    )
    
  def create_post(self, blog_guid, author_name, author_email, title, summary, content, tags):
    tag_xml = ''
    for tag in tags:
      tag_xml += '<category term="tag %s" />' % tag
    post = '''<?xml version="1.0" encoding="utf-8"?>
              <entry xmlns="http://www.w3.org/2005/Atom">
                <title>%s</title>
                  <author>
                    <name>%s</name>
                    <email>%s</email>
                  </author>
                  <summary>%s</summary>
                  <content type="html"><![CDATA[%s]]></content>
                  %s
              </entry>''' % (title, author_name, author_email, summary, content, tag_xml)
    hs_response = self._make_request_blog('%s/posts.atom' % blog_guid, {}, content_type='application/atom+xml', data=post, request_method='POST')
    parsed_xml = minidom.parseString(hs_response)
    inv_blog_post_obj = BlogPost(parsed_xml)
    return inv_blog_post_obj
  
  def update_post(self, post_guid, title, summary, content, meta_desc, meta_keyword, tags):
    tag_xml = ''
    for tag in tags:
      tag_xml += '<category term="tag %s" />' % tag
    post = '''<?xml version="1.0" encoding="utf-8"?>
              <entry xmlns="http://www.w3.org/2005/Atom" xmlns:hs="http://www.hubspot.com/">
                <title>%s</title>
                <summary>%s</summary>
                <content type="text">%s</content>
                %s
                <hs:metaDescription>%s</hs:metaDescription>
                <hs:metaKeywords>%s</hs:metaKeywords>
              </entry>''' % (title, summary, content, tag_xml, meta_desc, meta_keyword)
    hs_response = self._make_request_blog('posts/%s.atom' % post_guid, {}, content_type='application/atom+xml', data=post, request_method='PUT')
    parsed_xml = minidom.parseString(hs_response)
    inv_blog_post_obj = BlogPost(parsed_xml)
    return inv_blog_post_obj
  
  def publish_post(self, post_guid, publish_time, is_draft, should_notify):
    post = '''<?xml version="1.0" encoding="utf-8"?>
              <entry xmlns="http://www.w3.org/2005/Atom" xmlns:hs="http://www.hubspot.com/">
                <published>%s</published>
                <hs:draft>%s</hs:draft>
                <hs:sendNotifications>%s</hs:sendNotifications>
              </entry>''' % (publish_time, is_draft, should_notify)
    hs_response = self._make_request_blog('posts/%s.atom' % post_guid, {}, content_type = 'application/atom+xml', data=post, request_method='PUT')
    parsed_xml = minidom.parseString(hs_response)
    inv_blog_post_obj = BlogPost(parsed_xml)
    return inv_blog_post_obj
    
  def create_comment(self, post_guid, author_name, author_email, author_uri, content):
    post = '''<?xml version="1.0" encoding="utf-8"?>
              <entry xmlns="http://www.w3.org/2005/Atom">
                <author>
                  <name>%s</name>
                  <email>%s</email>
                  <uri>%s</uri>
                </author>
                <content type="html"><![CDATA[%s]]></content>
              </entry>''' % (author_name, author_email, author_uri, content)
    hs_response = self._make_request_blog('posts/%s/comments.atom' % post_guid, {}, content_type='application/atom+xml', data=post, request_method='POST')
    parsed_xml = minidom.parseString(hs_response)
    inv_blog_post_obj = BlogComment(parsed_xml)
    return inv_blog_post_obj

class HubSpotKeywordClient(HubSpotClient):
  
  def __init__(self, api_key, portal_id):
    self.api_key = api_key
    self.portal_id = str(portal_id)
  
  def _create_path(self, method):
    return 'keywords/v%s/%s' % (HUBSPOT_KEYWORDS_API_VERSION, method)
    
  def get_keywords(self):
    return self._make_request('keywords', {})
    
  def get_keyword(self, keyword_guid):
    return self._make_request('keywords/%s' % keyword_guid, {})
    
  def add_keyword(self, keyword):
    data = []
    for k in keyword:
      if k != '':
        data.append(dict(keyword=str(k)))
    return self._make_request('keywords', {}, data=str(data), request_method='PUT')
    
  def delete_keyword(self, keyword_guid):
    return self._make_request('keywords/%s' % keyword_guid, {}, request_method='DELETE')
    
  def refresh_all_keywords(self):
    return self._make_request('keywords/*/refresh', {})
    
  def refresh_keyword(self, keyword_guid):
    return self._make_request('keywords/%s/refresh' % keyword_guid, {})


class HubSpotSocialClient(HubSpotClient):

  def __init__(self, api_key, portal_id):
    self.api_key = api_key
    self.portal_id = str(portal_id)
  
  def _create_path(self, method):
    return 'social/v%s/%s' % (HUBSPOT_KEYWORDS_API_VERSION, method)
  

# UTILITIES

def _hs_decode(s):
  return base64.urlsafe_b64decode(s + '=' * (4 - len(s) % 4))

def verify_signed_hubspot_request(signed_request):
  """
  Return the payload from the signed request, or raise an informative
  exception if it fails to decode properly
  """
  if not signed_request:
      raise Exception("No signed request passed in")

  signed_request = str(signed_request) # convert from unicode

  if "." not in signed_request:
      raise Exception("improperly formed signed request -- missing '.'")

  signature, payload = signed_request.split(".",1)
  if not signature:
      raise Exception("No signature found in signed request")

  decoded_signature = _hs_decode(signature)
  decoded_payload = _hs_decode(payload)

  expected_signature = hmac.new(MARKETPLACE_SECRET, decoded_payload, hashlib.sha1).digest()

  if(expected_signature != decoded_signature):
      raise Exception("Signature doesn't match expectation")

  return decoded_payload
